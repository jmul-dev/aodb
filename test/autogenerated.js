const tape = require("tape");
const run = require("./helpers/run");
const put = require("./helpers/put");
const create = require("./helpers/create");
const validate = require("./helpers/fuzzing").validate;
const EthCrypto = require("eth-crypto");
const { privateKey: privateKey0, publicKey: writerAddress0 } = EthCrypto.createIdentity();
const { privateKey: privateKey1, publicKey: writerAddress1 } = EthCrypto.createIdentity();

tape("autogenerated failing fuzz test #1", (t) => {
	const writesPerReplication = [
		[
			[
				"wildStringSchema/*",
				["schema/*", "schema/*"]
			],
			[
				"schema/*",
				[
					{ keySchema: "*", valueValidationKey: "", keyValidation: "" },
					{ keySchema: "*", valueValidationKey: "", keyValidation: "" }
				]
			],
			[
				"wildStringSchema/*/*",
				["schema/*/*", "schema/*/*"]
			],
			[
				"schema/*/*",
				[
					{ keySchema: "*/*", valueValidationKey: "", keyValidation: "" },
					{ keySchema: "*/*", valueValidationKey: "", keyValidation: "" }
				]
			],
			[
				"wildStringSchema/*/*/*",
				["schema/*/*/*", "schema/*/*/*"]
			],
			[
				"schema/*/*/*",
				[
					{ keySchema: "*/*/*", valueValidationKey: "", keyValidation: "" },
					{ keySchema: "*/*/*", valueValidationKey: "", keyValidation: "" }
				]
			],
			["fefhe", [null, "hgbbhiegadhdeegdebfa"]],
			["gjegc/gjegc", ["jegahfeddccagaaghgce"]],
			["gjegc/gidjb", ["jjbchagfijbhiiijcaig"]],
			["gjegc/feffb", ["eiebhdddigbhheaacjdj"]],
			["gjegc/feigc", [null, "ajfgdihjedbcdhjgcaed"]],
			["gjegc/adifa", [null, "fghhbhchhdbidbbbfabh"]]
		],
		[
			["gjegc/caghc", ["gfjcgaebibbccjceggej"]],
			["gjegc/ghbdb", [null, "ggbddcahebaejbegaceh"]],
			["gjegc/aaahi/aaahi", ["bibggfheidahefhhgdci"]]
		]
	].map((b) => new Map(b));

	create.many(2, (err, dbs, replicateByIndex) => {
		t.error(err);

		// Batch insert schemas
		const batchSchemaList = [
			{
				type: "add-schema",
				key: "schema/*",
				value: {
					keySchema: "*",
					valueValidationKey: "",
					keyValidation: ""
				}
			},
			{
				type: "add-schema",
				key: "schema/*/*",
				value: {
					keySchema: "*/*",
					valueValidationKey: "",
					keyValidation: ""
				}
			},
			{
				type: "add-schema",
				key: "schema/*/*/*",
				value: {
					keySchema: "*/*/*",
					valueValidationKey: "",
					keyValidation: ""
				}
			}
		];
		for (let schema of batchSchemaList) {
			schema.writerSignature = EthCrypto.sign(privateKey0, dbs[0].createSignHash(schema.key, schema.value));
			schema.writerAddress = writerAddress0;
		}
		dbs[0].batch(batchSchemaList, (err) => {
			t.error(err, "no error");

			for (let schema of batchSchemaList) {
				schema.writerSignature = EthCrypto.sign(privateKey1, dbs[1].createSignHash(schema.key, schema.value));
				schema.writerAddress = writerAddress1;
			}

			dbs[1].batch(batchSchemaList, (err) => {
				t.error(err, "no error");

				run(
					(cb) => {
						put(
							dbs[1],
							privateKey1,
							writerAddress1,
							[
								{
									key: "fefhe",
									value: "hgbbhiegadhdeegdebfa"
								}
							],
							{ schemaKey: "schema/*" },
							cb
						);
					},
					(cb) => {
						put(
							dbs[0],
							privateKey0,
							writerAddress0,
							[
								{
									key: "gjegc/gjegc",
									value: "jegahfeddccagaaghgce"
								}
							],
							{ schemaKey: "schema/*/*" },
							cb
						);
					},
					(cb) => {
						put(
							dbs[0],
							privateKey0,
							writerAddress0,
							[
								{
									key: "gjegc/gidjb",
									value: "jjbchagfijbhiiijcaig"
								}
							],
							{ schemaKey: "schema/*/*" },
							cb
						);
					},
					(cb) => {
						put(
							dbs[0],
							privateKey0,
							writerAddress0,
							[
								{
									key: "gjegc/feffb",
									value: "eiebhdddigbhheaacjdj"
								}
							],
							{ schemaKey: "schema/*/*" },
							cb
						);
					},
					(cb) => {
						put(
							dbs[1],
							privateKey1,
							writerAddress1,
							[
								{
									key: "gjegc/feigc",
									value: "ajfgdihjedbcdhjgcaed"
								}
							],
							{ schemaKey: "schema/*/*" },
							cb
						);
					},
					(cb) => {
						put(
							dbs[1],
							privateKey1,
							writerAddress1,
							[
								{
									key: "gjegc/adifa",
									value: "fghhbhchhdbidbbbfabh"
								}
							],
							{ schemaKey: "schema/*/*" },
							cb
						);
					},
					(cb) => replicateByIndex(cb),
					(cb) => validate(t, dbs[0], writesPerReplication.slice(0, 1), cb),
					(cb) => {
						put(
							dbs[0],
							privateKey0,
							writerAddress0,
							[
								{
									key: "gjegc/caghc",
									value: "gfjcgaebibbccjceggej"
								}
							],
							{ schemaKey: "schema/*/*" },
							cb
						);
					},
					(cb) => {
						put(
							dbs[1],
							privateKey1,
							writerAddress1,
							[
								{
									key: "gjegc/ghbdb",
									value: "ggbddcahebaejbegaceh"
								}
							],
							{ schemaKey: "schema/*/*" },
							cb
						);
					},
					(cb) => {
						put(
							dbs[0],
							privateKey0,
							writerAddress0,
							[
								{
									key: "gjegc/aaahi/aaahi",
									value: "bibggfheidahefhhgdci"
								}
							],
							{ schemaKey: "schema/*/*/*" },
							cb
						);
					},
					(cb) => replicateByIndex(cb),
					(cb) => validate(t, dbs[0], writesPerReplication.slice(0, 2), cb),
					(err) => {
						t.error(err);
						t.end();
					}
				);
			});
		});
	});
});
